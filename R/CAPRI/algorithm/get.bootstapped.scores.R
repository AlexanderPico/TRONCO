#### get.bootstapped.scores.R
####
#### TRONCO: a tool for TRanslational ONCOlogy
####
#### See the files COPYING and LICENSE for copyright and licensing
#### information.


# compute a robust estimation of the scores using rejection sampling bootstrap
# INPUT:
# dataset: a valid dataset
# nboot: number of bootstrap resampling to be performed
# adj.matrix: adjacency matrix of the initially valid edges
# min.boot: minimum number of bootstrapping to be performed
# min.stat: should I keep bootstrapping untill I have nboot valid values?
# boot.seed: seed to be used for the sampling
# RETURN:
# scores: list structure with the scores and the data generated by bootstrap
"get.bootstapped.scores" <-
function( dataset, nboot, adj.matrix, min.boot = 3, min.stat = TRUE, boot.seed = 12345 ) {
	
    # structures to save the distributions generated by the bootstrapped datasets
    marginal.probs.distributions <- array(list(-1), c(ncol(dataset),1));
    joint.probs.distributions <- array(list(-1), c(ncol(dataset),ncol(dataset)));
    prima.facie.model.distributions <- array(list(-1), c(ncol(dataset),ncol(dataset)));
    prima.facie.null.distributions <- array(list(-1), c(ncol(dataset),ncol(dataset)));
    # structures to save the number of performed valid (not rejected) sampling
    sampled.marginal.probs.distributions <- array(0, dim=c(ncol(dataset),1));
    sampled.joint.probs.distributions <- array(0, dim=c(ncol(dataset),ncol(dataset)));
    sampled.prima.facie.distributions <- array(0, dim=c(ncol(dataset),ncol(dataset)));
    
    # I require a minimum of min.boot (default = 3) sampling of bootstrap
    nboot = max(nboot,min.boot);
    
    # set not to sample for the invalid edges
	for(i in 1:nrow(adj.matrix)) {
	    for(j in 1:ncol(adj.matrix)) {
            if(adj.matrix[i,j]==0) {
                sampled.prima.facie.distributions[i,j] = nboot;
            }
        }
    }
    
    # perform bootstrap estimation based on a number of bootstrapped (>= nboot) datasets
    curr.iteration = min(sampled.prima.facie.distributions);
    boot.counter = 0;
    
    # set the seed to be used for the sampling
    set.seed(boot.seed);
    
    # create a progress bar
    flush.console();
    pb <- txtProgressBar(curr.iteration, nboot, style = 3);
    
    while(curr.iteration<nboot) {
    		
        # define the dataset to be used in this iteration and compute the scores on it
        sampled.data = dataset[sample(1:nrow(dataset),size=nrow(dataset),replace=TRUE),];
        boot.counter = boot.counter + 1;
        
        # compute the scores on the sampled data
        curr.scores = get.dag.scores(sampled.data,adj.matrix);
        curr.marginal.probs = curr.scores$marginal.probs;
        curr.joint.probs = curr.scores$joint.probs;
        curr.prima.facie.model = curr.scores$prima.facie.model;
        curr.prima.facie.null = curr.scores$prima.facie.null;
        
        # save the (valid) scores for each edge
        for(i in 1:nrow(curr.prima.facie.model)) {
        	
            # get the marginal probabilities from the sampled data
            if(sampled.marginal.probs.distributions[i,1]==0) {
                sampled.marginal.probs.distributions[i,1] = 1;
                marginal.probs.distributions[i,1] = curr.marginal.probs[i,1];
            }
            else {
                marginal.probs.distributions[i,1] = list(c(unlist(marginal.probs.distributions[i,1]),curr.marginal.probs[i,1]));
            }
            
            for(j in 1:ncol(curr.prima.facie.model)) {
            	
                # get the joint probs from the sampled data
                if(sampled.joint.probs.distributions[i,j]==0) {
                    sampled.joint.probs.distributions[i,j] = 1;
                    joint.probs.distributions[i,j] = curr.joint.probs[i,j];
                }
                else {
                    joint.probs.distributions[i,j] = list(c(unlist(joint.probs.distributions[i,j]),curr.joint.probs[i,j]));
                }
                
                # get the prima facie estimations from the sampled data
                if(curr.prima.facie.model[i,j]!=-1) {
                    # count the valid values per edge
                    sampled.prima.facie.distributions[i,j] = sampled.prima.facie.distributions[i,j] + 1;
                    # save the scores
                    if(sampled.prima.facie.distributions[i,j]==1) {
                        # scores for i --> j
                        prima.facie.model.distributions[i,j] = list(curr.prima.facie.model[i,j]);
                        prima.facie.null.distributions[i,j] = list(curr.prima.facie.null[i,j]);
                    }
                    else {
                        # scores for i --> j
                        prima.facie.model.distributions[i,j] = list(c(unlist(prima.facie.model.distributions[i,j]),curr.prima.facie.model[i,j]));
                        prima.facie.null.distributions[i,j] = list(c(unlist(prima.facie.null.distributions[i,j]),curr.prima.facie.null[i,j]));
                    }
                }
                
            }
            
        }
		
		# set the number of performed iterations after the last bootstrap sampling
		curr.iteration = min(sampled.prima.facie.distributions);
		
		# if the flag min.stat is FALSE,
		# even if after nboot iterations I don't have nboot valid entries,
		# as soon as I have at least min.boot values, I stop anyway
		if(min.stat==FALSE && boot.counter>=nboot && curr.iteration>=min.boot) {
			curr.iteration = nboot;
		}
		
		#increment the progress bar
		if(min.stat==FALSE) {
			setTxtProgressBar(pb, boot.counter);
		}
		else {
			setTxtProgressBar(pb, curr.iteration);
		}
	
	}
	
	# close the progress bar
    close(pb);
    
    # save the results and return them
    scores <- list(marginal.probs.distributions=marginal.probs.distributions,joint.probs.distributions=joint.probs.distributions,prima.facie.model.distributions=prima.facie.model.distributions,prima.facie.null.distributions=prima.facie.null.distributions);
    return(scores);
    
}

#### end of file -- get.bootstapped.scores.R
